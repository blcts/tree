{"ast":null,"code":"const BASE_URL = 'https://mate.academy/students-api'; // a promise resolved after a given delay\n\nfunction wait(delay) {\n  return new Promise(resolve => {\n    setTimeout(resolve, delay);\n  });\n} // To have autocompletion and avoid mistypes\n\n\nfunction request(url) {\n  let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GET';\n  let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const options = {\n    method\n  };\n\n  if (data) {\n    // We add body and Content-Type only for the requests with data\n    options.body = JSON.stringify(data);\n    options.headers = {\n      'Content-Type': 'application/json; charset=UTF-8'\n    };\n  } // we wait for testing purpose to see loaders\n\n\n  return wait(300).then(() => fetch(BASE_URL + url, options)).then(response => {\n    if (!response.ok) {\n      throw new Error();\n    }\n\n    return response.json();\n  });\n}\n\nexport const client = {\n  get: url => request(url),\n  post: (url, data) => request(url, 'POST', data),\n  patch: (url, data) => request(url, 'PATCH', data),\n  delete: url => request(url, 'DELETE')\n};","map":{"version":3,"names":["BASE_URL","wait","delay","Promise","resolve","setTimeout","request","url","method","data","options","body","JSON","stringify","headers","then","fetch","response","ok","Error","json","client","get","post","patch","delete"],"sources":["/Users/lizaz/fed-exam-category-tree-blcts/src/utils/fetchClient.ts"],"sourcesContent":["const BASE_URL = 'https://mate.academy/students-api';\n\n// a promise resolved after a given delay\nfunction wait(delay: number) {\n  return new Promise(resolve => {\n    setTimeout(resolve, delay);\n  });\n}\n\n// To have autocompletion and avoid mistypes\ntype RequestMethod = 'GET' | 'POST' | 'PATCH' | 'DELETE';\n\nfunction request<T>(\n  url: string,\n  method: RequestMethod = 'GET',\n  data: any = null, // we can send any data to the server\n): Promise<T> {\n  const options: RequestInit = { method };\n\n  if (data) {\n    // We add body and Content-Type only for the requests with data\n    options.body = JSON.stringify(data);\n    options.headers = {\n      'Content-Type': 'application/json; charset=UTF-8',\n    };\n  }\n\n  // we wait for testing purpose to see loaders\n  return wait(300)\n    .then(() => fetch(BASE_URL + url, options))\n    .then(response => {\n      if (!response.ok) {\n        throw new Error();\n      }\n\n      return response.json();\n    });\n}\n\nexport const client = {\n  get: <T>(url: string) => request<T>(url),\n  post: <T>(url: string, data: any) => request<T>(url, 'POST', data),\n  patch: <T>(url: string, data: any) => request<T>(url, 'PATCH', data),\n  delete: (url: string) => request(url, 'DELETE'),\n};\n"],"mappings":"AAAA,MAAMA,QAAQ,GAAG,mCAAjB,C,CAEA;;AACA,SAASC,IAAT,CAAcC,KAAd,EAA6B;EAC3B,OAAO,IAAIC,OAAJ,CAAYC,OAAO,IAAI;IAC5BC,UAAU,CAACD,OAAD,EAAUF,KAAV,CAAV;EACD,CAFM,CAAP;AAGD,C,CAED;;;AAGA,SAASI,OAAT,CACEC,GADF,EAIc;EAAA,IAFZC,MAEY,uEAFY,KAEZ;EAAA,IADZC,IACY,uEADA,IACA;EACZ,MAAMC,OAAoB,GAAG;IAAEF;EAAF,CAA7B;;EAEA,IAAIC,IAAJ,EAAU;IACR;IACAC,OAAO,CAACC,IAAR,GAAeC,IAAI,CAACC,SAAL,CAAeJ,IAAf,CAAf;IACAC,OAAO,CAACI,OAAR,GAAkB;MAChB,gBAAgB;IADA,CAAlB;EAGD,CATW,CAWZ;;;EACA,OAAOb,IAAI,CAAC,GAAD,CAAJ,CACJc,IADI,CACC,MAAMC,KAAK,CAAChB,QAAQ,GAAGO,GAAZ,EAAiBG,OAAjB,CADZ,EAEJK,IAFI,CAECE,QAAQ,IAAI;IAChB,IAAI,CAACA,QAAQ,CAACC,EAAd,EAAkB;MAChB,MAAM,IAAIC,KAAJ,EAAN;IACD;;IAED,OAAOF,QAAQ,CAACG,IAAT,EAAP;EACD,CARI,CAAP;AASD;;AAED,OAAO,MAAMC,MAAM,GAAG;EACpBC,GAAG,EAAMf,GAAJ,IAAoBD,OAAO,CAAIC,GAAJ,CADZ;EAEpBgB,IAAI,EAAE,CAAIhB,GAAJ,EAAiBE,IAAjB,KAA+BH,OAAO,CAAIC,GAAJ,EAAS,MAAT,EAAiBE,IAAjB,CAFxB;EAGpBe,KAAK,EAAE,CAAIjB,GAAJ,EAAiBE,IAAjB,KAA+BH,OAAO,CAAIC,GAAJ,EAAS,OAAT,EAAkBE,IAAlB,CAHzB;EAIpBgB,MAAM,EAAGlB,GAAD,IAAiBD,OAAO,CAACC,GAAD,EAAM,QAAN;AAJZ,CAAf"},"metadata":{},"sourceType":"module"}